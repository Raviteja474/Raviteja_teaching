why OOPS??

Procedural vs oops language

Examples

Advantages

OOPS concepts:

Object
1. Inheritance
 parent class = base class = super class
 subclass = child class = derived class
2. Polymorphism

3. Abstraction
4. Encapsulation






# class = how a object should be/blueprint(class Person defines how a person should be)

# object = physical presence(Avinash should follow Person class)
that contains data(variables/methods)

1. static method
     @classmethod, @staticmethod,
2. non-static method
    first parameter self
3. Static variable
    global scope, class method
4. non-static variable
    variables in non-static method



Eg:1 class laptop
    object lenovo, dell, Thinkpad
    object properties/ attributes: display,CPU, Hard disk

Eg:2 class Person
    object Avinash, Ganesh, Bharath
    object properties/ attributes: legs,hands, eyes

Eg:3 class Building design
    object Tajmahal design, charminar design
    object properties/ attributes: paint, bricks, steel

class contains methods and variables normally but not mandatory
we can create multiple objects to a same class

object= instance= reference

 instance methods = non-class methods = non-static methods; with self as first parameter
 non-instance methods = class methods = static methods

 constructor = initializer method = init method

 Amoeba -->  Fish  --> Dolphin --> shark --> whale
                --> dinosaur --> crocodile
                --> cats --> tiger , lion
                --> mammal --> monkey --> chimpanzee--> human  --> Umamahesh, Niramla, Ravi


 OOPS:  Object oriented programming

 1. Inheritance - varasatvam
 python: class will inherit it's parent class
 Man class will inherit chimpanzee class.

 subclass = child class
 parent class = base class = super class

 # 19@@ a method should take from only existing class, how?

 2. Polymorphism - multiple forms
 Object will behave differently based on your way/number of inputs.

 Eg: can_see = True, he will enjoy nature.
 can_see = False, He is a blind.
 Types:
 Dynamic polymorphism= overriding = run time polymorphism
 static polymorphism = overloading = compile time polymorphism

 3. Abstraction - expressing total content with small portion of sentences
 Hiding implementation to end user and displaying the result only.
 Forcing user to implment that.

 abstract method = non-concrete method
 non-abstract method = concrete method

 4. encapsulation - bundling/binding many tiny elements into one

 idea of wrapping data and the methods that work on data within one unit

 private members, protected members


# TypeError: Class3.m() missing 1 required positional argument: 'self'
# u need to call that using object only.

# implemtation =some valid statement except "pass"

issubclass
isinstance








